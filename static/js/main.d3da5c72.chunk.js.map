{"version":3,"sources":["App.module.scss","helpers.ts","App.tsx","constants.ts","serviceWorker.ts","index.tsx"],"names":["module","exports","combineMerge","target","source","options","destination","slice","forEach","item","index","cloneUnlessOtherwiseSpecified","isMergeableObject","merge","indexOf","push","widgetSDK","require","dot","Dot","mapErrorMessagesToIds","App","state","carouselData","isInitializing","isLoadingData","isActive","selectedAction","undefined","errors","initWidget","a","setState","init","event","type","metaData","items_url","axios","get","then","response","data","items_json","JSON","parse","Object","keys","find","key","includes","nextCarouselData","items","filter","object","arrayMerge","console","error","prevState","onActionClickHandler","payload","url","widgetIsActive","sendUserData","selectedItem","errorMessage","newWindow","window","open","opener","this","prevProps","snapshot","length","sliderSettings","accessibility","infinite","slidesToShow","className","styles","wrapper","loader","loadingSpinner","inactive","map","slide","id","title","media","img","src","mediaurl","alt","info","description","actions","action","text","activeBtn","onClick","uri","Component","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.d3da5c72.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"App_wrapper__RCHjb\",\"slide\":\"App_slide__3wo5f\",\"inactive\":\"App_inactive__3sm8u\",\"loader\":\"App_loader__Dop8H\",\"loadingSpinner\":\"App_loadingSpinner__mDfBX\",\"media\":\"App_media__3AUMG\",\"img\":\"App_img__KttCg\",\"info\":\"App_info__TsZcg\",\"actions\":\"App_actions__3Fim5\",\"action\":\"App_action__3GOU7\",\"activeBtn\":\"App_activeBtn__mek8F\"};","import merge, { Options } from 'deepmerge';\n\ninterface CombineMergeOptions extends Options {\n  cloneUnlessOtherwiseSpecified: <T>(item: Partial<T>, options: CombineMergeOptions) => Partial<T>;\n  isMergeableObject: <T>(item: Partial<T>) => boolean;\n}\n\nexport const combineMerge = <T>(target: Partial<T>[], source: Partial<T>[], options: CombineMergeOptions) => {\n  const destination = target.slice();\n\n  source.forEach((item: Partial<T>, index: number) => {\n    if (typeof destination[index] === 'undefined') {\n      destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);\n    } else if (options.isMergeableObject(item)) {\n      destination[index] = merge(target[index], item, options);\n    } else if (target.indexOf(item) === -1) {\n      destination.push(item);\n    }\n  });\n\n  return destination;\n};\n","import React, { Component } from 'react';\nimport Slider from 'react-slick';\nimport axios from 'axios';\nimport Dot from 'dot-object';\nimport merge from 'deepmerge';\n\nimport { combineMerge } from './helpers';\n\nimport { ACTION_TYPE_POSTBACK, ACTION_TYPE_LINK } from './constants';\n\nimport { CarouselData, CarouselItem, widgetEvent } from './types';\nimport styles from './App.module.scss';\n\nconst AdaWidgetSDK = require('@ada-support/ada-widget-sdk');\nconst widgetSDK = new AdaWidgetSDK();\nconst dot = new Dot('_');\nconst mapErrorMessagesToIds = {\n  noData: 'Error: No data provided',\n  initFail: 'Error: Initialization Failed',\n  errorGetData: 'Error: Failed to get data',\n  postbackError: 'Error: Postback sending error',\n};\n\ninterface State {\n  carouselData: null | CarouselData;\n  isInitializing: boolean;\n  isLoadingData: boolean;\n  isActive: boolean;\n  selectedAction: string | undefined;\n  errors: string[];\n}\n\nclass App extends Component<unknown, State> {\n  state: State = {\n    carouselData: null,\n    isInitializing: false,\n    isLoadingData: false,\n    isActive: false,\n    selectedAction: undefined,\n    errors: [],\n  };\n\n  componentDidMount() {\n    this.initWidget();\n  }\n\n  componentDidUpdate(prevProps: Readonly<unknown>, prevState: Readonly<State>, snapshot?: any) {\n    const { errors } = this.state;\n\n    if (!widgetSDK.widgetIsActive && prevState.isActive) {\n      console.error(mapErrorMessagesToIds.initFail);\n      this.setState((prevState) => ({\n        isActive: false,\n        errors: [...prevState.errors, mapErrorMessagesToIds.initFail],\n      }));\n    }\n\n    if (errors.length !== prevState.errors.length) {\n      if (widgetSDK.widgetIsActive) {\n        widgetSDK.sendUserData(\n          {\n            selectedItem: null,\n            errorMessage: errors,\n          },\n          // eslint-disable-next-line @typescript-eslint/no-empty-function\n          () => {},\n        );\n      }\n    }\n  }\n\n  initWidget = async () => {\n    try {\n      this.setState({ isInitializing: true });\n\n      await widgetSDK.init((event: widgetEvent) => {\n        this.setState({\n          isInitializing: false,\n          isActive: true,\n        });\n\n        switch (event.type) {\n          case 'WIDGET_INITIALIZED': {\n            this.setState({ isLoadingData: true });\n            if (event.metaData.items_url) {\n              // API Url\n              axios.get(event.metaData.items_url).then((response) => {\n                this.setState({\n                  isLoadingData: false,\n                  carouselData: response.data,\n                });\n              });\n            } else if (event.metaData.items_json) {\n              // JSON\n              this.setState({\n                isLoadingData: false,\n                carouselData: JSON.parse(event.metaData.items_json),\n              });\n            } else if (Object.keys(event.metaData).find((key) => key.includes('items'))) {\n              // User Params\n              let nextCarouselData: CarouselData = { items: [] };\n              Object.keys(event.metaData)\n                .filter((key) => key.includes('items'))\n                .forEach((key) => {\n                  nextCarouselData = merge(nextCarouselData, dot.object({ [key]: event.metaData[key] }), {\n                    arrayMerge: combineMerge,\n                  });\n                });\n\n              this.setState({\n                isLoadingData: false,\n                carouselData: nextCarouselData,\n              });\n            } else {\n              console.error(mapErrorMessagesToIds.noData);\n              this.setState((prevState) => ({\n                isActive: false,\n                errors: [...prevState.errors, mapErrorMessagesToIds.noData],\n              }));\n            }\n            break;\n          }\n          case 'WIDGET_INITIALIZATION_FAILED': {\n            console.error(mapErrorMessagesToIds.initFail);\n            this.setState((prevState) => ({\n              isActive: false,\n              errors: [...prevState.errors, mapErrorMessagesToIds.initFail],\n            }));\n          }\n        }\n      });\n    } catch (e) {\n      this.setState({ isInitializing: false });\n      console.error(mapErrorMessagesToIds.errorGetData, e);\n      this.setState((prevState) => ({\n        isActive: false,\n        errors: [...prevState.errors, mapErrorMessagesToIds.errorGetData],\n      }));\n    }\n  };\n\n  onActionClickHandler = (type: string, payload: string | undefined, url: string | undefined) => {\n    const { errors } = this.state;\n\n    switch (type) {\n      case ACTION_TYPE_POSTBACK: {\n        if (widgetSDK.widgetIsActive) {\n          widgetSDK.sendUserData(\n            {\n              selectedItem: payload,\n              errorMessage: errors,\n            },\n            (event: { type: string }) => {\n              if (event.type === 'SEND_USER_DATA_SUCCESS') {\n                this.setState({\n                  selectedAction: payload,\n                  isActive: false,\n                });\n              } else {\n                console.error(mapErrorMessagesToIds.postbackError);\n                this.setState((prevState) => ({\n                  isActive: false,\n                  errors: [...prevState.errors, mapErrorMessagesToIds.postbackError],\n                }));\n              }\n            },\n          );\n        }\n        break;\n      }\n      case ACTION_TYPE_LINK: {\n        const newWindow = window.open(url, '_blank', 'noopener,noreferrer');\n\n        if (newWindow) newWindow.opener = null;\n\n        break;\n      }\n    }\n  };\n\n  render() {\n    const { carouselData, isInitializing, isLoadingData, isActive, selectedAction } = this.state;\n    const sliderSettings = {\n      accessibility: true,\n      infinite: false,\n      slidesToShow: carouselData?.items && (carouselData?.items as CarouselItem[]).length > 1 ? 1.1 : 1,\n    };\n\n    return (\n      <div className={styles.wrapper}>\n        {(isInitializing || isLoadingData) && (\n          <div className={styles.loader}>\n            <div className={styles.loadingSpinner} />\n          </div>\n        )}\n        {!isActive && <div className={styles.inactive} />}\n        <Slider {...sliderSettings}>\n          {carouselData?.items.map((slide) => {\n            return (\n              <div key={slide.id || slide.title}>\n                <div className={styles.slide}>\n                  <div className={styles.media}>\n                    <img className={styles.img} src={slide.mediaurl} alt={slide.title} />\n                  </div>\n                  <div className={styles.info}>\n                    <h3 className={styles.title}>{slide.title}</h3>\n                    <p className={styles.description}>{slide.description}</p>\n                  </div>\n                  <div className={styles.actions}>\n                    {slide.actions.map((action) => (\n                      <button\n                        key={action.text}\n                        className={`${styles.action} ${\n                          selectedAction && selectedAction === action.payload && styles.activeBtn\n                        }`}\n                        onClick={() => this.onActionClickHandler(action.type, action.payload, action.uri)}\n                      >\n                        {action.text}\n                      </button>\n                    ))}\n                  </div>\n                </div>\n              </div>\n            );\n          })}\n        </Slider>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","export const ACTION_TYPE_POSTBACK = 'postback';\nexport const ACTION_TYPE_LINK = 'link';\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport './index.scss';\nimport 'slick-carousel/slick/slick.css';\nimport 'slick-carousel/slick/slick-theme.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}