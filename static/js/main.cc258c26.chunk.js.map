{"version":3,"sources":["App.module.scss","no-img.svg","helpers.ts","App.tsx","constants.ts","serviceWorker.ts","index.tsx"],"names":["module","exports","combineMerge","target","source","options","destination","slice","forEach","item","index","cloneUnlessOtherwiseSpecified","isMergeableObject","merge","indexOf","push","widgetSDK","require","dot","Dot","mapErrorMessagesToIds","App","state","carouselData","isInitializing","isLoadingData","isActive","selectedAction","undefined","errors","slideImgError","initWidget","a","setState","init","event","type","metaData","items_url","axios","get","then","response","data","items_json","JSON","parse","Object","keys","find","key","includes","nextCarouselData","items","filter","object","arrayMerge","console","error","prevState","onActionClickHandler","payload","url","widgetIsActive","sendUserData","selectedItem","errorMessage","newWindow","window","open","opener","onImgError","this","prevProps","snapshot","length","sliderSettings","accessibility","infinite","slidesToShow","className","styles","wrapper","loader","loadingSpinner","inactive","map","slide","id","title","media","mediaurl","img","src","alt","onError","noImg","info","description","actions","action","text","activeBtn","onClick","uri","Component","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.cc258c26.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"App_wrapper__RCHjb\",\"inactive\":\"App_inactive__3sm8u\",\"loader\":\"App_loader__Dop8H\",\"loadingSpinner\":\"App_loadingSpinner__mDfBX\",\"slide\":\"App_slide__3wo5f\",\"media\":\"App_media__3AUMG\",\"img\":\"App_img__KttCg\",\"noImg\":\"App_noImg__1ahWu\",\"title\":\"App_title__2oBiX\",\"description\":\"App_description__A-JFl\",\"info\":\"App_info__TsZcg\",\"actions\":\"App_actions__3Fim5\",\"action\":\"App_action__3GOU7\",\"activeBtn\":\"App_activeBtn__mek8F\"};","module.exports = __webpack_public_path__ + \"static/media/no-img.c3fbefb0.svg\";","import merge, { Options } from 'deepmerge';\n\ninterface CombineMergeOptions extends Options {\n  cloneUnlessOtherwiseSpecified: <T>(item: Partial<T>, options: CombineMergeOptions) => Partial<T>;\n  isMergeableObject: <T>(item: Partial<T>) => boolean;\n}\n\nexport const combineMerge = <T>(target: Partial<T>[], source: Partial<T>[], options: CombineMergeOptions) => {\n  const destination = target.slice();\n\n  source.forEach((item: Partial<T>, index: number) => {\n    if (typeof destination[index] === 'undefined') {\n      destination[index] = options.cloneUnlessOtherwiseSpecified(item, options);\n    } else if (options.isMergeableObject(item)) {\n      destination[index] = merge(target[index], item, options);\n    } else if (target.indexOf(item) === -1) {\n      destination.push(item);\n    }\n  });\n\n  return destination;\n};\n","import React, { Component } from 'react';\nimport Slider from 'react-slick';\nimport axios from 'axios';\nimport Dot from 'dot-object';\nimport merge from 'deepmerge';\n\nimport { combineMerge } from './helpers';\n\nimport { ACTION_TYPE_POSTBACK, ACTION_TYPE_LINK } from './constants';\n\nimport { CarouselData, CarouselItem, widgetEvent } from './types';\n\nimport noImg from './no-img.svg';\nimport styles from './App.module.scss';\n\nconst AdaWidgetSDK = require('@ada-support/ada-widget-sdk');\nconst widgetSDK = new AdaWidgetSDK();\nconst dot = new Dot('_');\nconst mapErrorMessagesToIds = {\n  noData: 'Error: No data provided',\n  initFail: 'Error: Initialization Failed',\n  errorGetData: 'Error: Failed to get data',\n  postbackError: 'Error: Postback sending error',\n};\n\ninterface State {\n  carouselData: null | CarouselData;\n  isInitializing: boolean;\n  isLoadingData: boolean;\n  isActive: boolean;\n  selectedAction: string | undefined;\n  errors: string[];\n  slideImgError: number | undefined;\n}\n\nclass App extends Component<unknown, State> {\n  state: State = {\n    carouselData: null,\n    isInitializing: false,\n    isLoadingData: false,\n    isActive: false,\n    selectedAction: undefined,\n    errors: [],\n    slideImgError: undefined,\n  };\n\n  componentDidMount() {\n    this.initWidget();\n  }\n\n  componentDidUpdate(prevProps: Readonly<unknown>, prevState: Readonly<State>, snapshot?: any) {\n    const { errors } = this.state;\n\n    if (!widgetSDK.widgetIsActive && prevState.isActive) {\n      console.error(mapErrorMessagesToIds.initFail);\n      this.setState((prevState) => ({\n        isActive: false,\n        errors: [...prevState.errors, mapErrorMessagesToIds.initFail],\n      }));\n    }\n\n    if (errors.length !== prevState.errors.length) {\n      if (widgetSDK.widgetIsActive) {\n        widgetSDK.sendUserData(\n          {\n            selectedItem: null,\n            errorMessage: errors,\n          },\n          // eslint-disable-next-line @typescript-eslint/no-empty-function\n          () => {},\n        );\n      }\n    }\n  }\n\n  initWidget = async () => {\n    try {\n      this.setState({ isInitializing: true });\n\n      await widgetSDK.init((event: widgetEvent) => {\n        this.setState({\n          isInitializing: false,\n          isActive: true,\n        });\n\n        switch (event.type) {\n          case 'WIDGET_INITIALIZED': {\n            this.setState({ isLoadingData: true });\n            if (event.metaData.items_url) {\n              // API Url\n              axios.get(event.metaData.items_url).then((response) => {\n                this.setState({\n                  isLoadingData: false,\n                  carouselData: response.data,\n                });\n              });\n            } else if (event.metaData.items_json) {\n              // JSON\n              this.setState({\n                isLoadingData: false,\n                carouselData: JSON.parse(event.metaData.items_json),\n              });\n            } else if (Object.keys(event.metaData).find((key) => key.includes('items'))) {\n              // User Params\n              let nextCarouselData: CarouselData = { items: [] };\n              Object.keys(event.metaData)\n                .filter((key) => key.includes('items'))\n                .forEach((key) => {\n                  nextCarouselData = merge(nextCarouselData, dot.object({ [key]: event.metaData[key] }), {\n                    arrayMerge: combineMerge,\n                  });\n                });\n\n              this.setState({\n                isLoadingData: false,\n                carouselData: nextCarouselData,\n              });\n            } else {\n              console.error(mapErrorMessagesToIds.noData);\n              this.setState((prevState) => ({\n                isActive: false,\n                errors: [...prevState.errors, mapErrorMessagesToIds.noData],\n              }));\n            }\n            break;\n          }\n          case 'WIDGET_INITIALIZATION_FAILED': {\n            console.error(mapErrorMessagesToIds.initFail);\n            this.setState((prevState) => ({\n              isActive: false,\n              errors: [...prevState.errors, mapErrorMessagesToIds.initFail],\n            }));\n          }\n        }\n      });\n    } catch (e) {\n      this.setState({ isInitializing: false });\n      console.error(mapErrorMessagesToIds.errorGetData, e);\n      this.setState((prevState) => ({\n        isActive: false,\n        errors: [...prevState.errors, mapErrorMessagesToIds.errorGetData],\n      }));\n    }\n  };\n\n  onActionClickHandler = (type: string, payload: string | undefined, url: string | undefined) => {\n    const { errors } = this.state;\n\n    switch (type) {\n      case ACTION_TYPE_POSTBACK: {\n        if (widgetSDK.widgetIsActive) {\n          widgetSDK.sendUserData(\n            {\n              selectedItem: payload,\n              errorMessage: errors,\n            },\n            (event: { type: string }) => {\n              if (event.type === 'SEND_USER_DATA_SUCCESS') {\n                this.setState({\n                  selectedAction: payload,\n                  isActive: false,\n                });\n              } else {\n                console.error(mapErrorMessagesToIds.postbackError);\n                this.setState((prevState) => ({\n                  isActive: false,\n                  errors: [...prevState.errors, mapErrorMessagesToIds.postbackError],\n                }));\n              }\n            },\n          );\n        }\n        break;\n      }\n      case ACTION_TYPE_LINK: {\n        const newWindow = window.open(url, '_blank', 'noopener,noreferrer');\n\n        if (newWindow) newWindow.opener = null;\n\n        break;\n      }\n    }\n  };\n\n  onImgError = (index: number) => {\n    this.setState({\n      slideImgError: index,\n    });\n  };\n\n  render() {\n    const { carouselData, isInitializing, isLoadingData, isActive, selectedAction, slideImgError } = this.state;\n    const sliderSettings = {\n      accessibility: true,\n      infinite: false,\n      slidesToShow: carouselData?.items && (carouselData?.items as CarouselItem[]).length > 1 ? 1.1 : 1,\n    };\n\n    return (\n      <div className={styles.wrapper}>\n        {(isInitializing || isLoadingData) && (\n          <div className={styles.loader}>\n            <div className={styles.loadingSpinner} />\n          </div>\n        )}\n        {!isActive && <div className={styles.inactive} />}\n        <Slider {...sliderSettings}>\n          {carouselData?.items.map((slide, index) => {\n            return (\n              <div key={slide.id || slide.title}>\n                <div className={styles.slide}>\n                  <div className={styles.media}>\n                    {!slide.mediaurl || slideImgError === index ? (\n                      <img className={styles.noImg} src={noImg} alt=\"broken url\" />\n                    ) : (\n                      <img\n                        className={styles.img}\n                        src={slide.mediaurl}\n                        alt={slide.title}\n                        onError={() => this.onImgError(index)}\n                      />\n                    )}\n                  </div>\n                  <div className={styles.info}>\n                    <h3 className={styles.title}>{slide.title}</h3>\n                    <p className={styles.description}>{slide.description}</p>\n                  </div>\n                  <div className={styles.actions}>\n                    {slide.actions.map((action) => {\n                      return (\n                        action && (\n                          <button\n                            key={action.text}\n                            className={`${styles.action} ${\n                              selectedAction && selectedAction === action.payload && styles.activeBtn\n                            }`}\n                            onClick={() => this.onActionClickHandler(action.type, action.payload, action.uri)}\n                          >\n                            {action.text}\n                          </button>\n                        )\n                      );\n                    })}\n                  </div>\n                </div>\n              </div>\n            );\n          })}\n        </Slider>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","export const ACTION_TYPE_POSTBACK = 'postback';\nexport const ACTION_TYPE_LINK = 'link';\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/),\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA',\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.',\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (response.status === 404 || (contentType != null && contentType.indexOf('javascript') === -1)) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport './index.scss';\nimport 'slick-carousel/slick/slick.css';\nimport 'slick-carousel/slick/slick-theme.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}